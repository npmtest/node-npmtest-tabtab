{"/home/travis/build/npmtest/node-npmtest-tabtab/test.js":"/* istanbul instrument in package npmtest_tabtab */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tabtab/lib.npmtest_tabtab.js":"/* istanbul instrument in package npmtest_tabtab */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_tabtab = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_tabtab = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-tabtab/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-tabtab && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_tabtab */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_tabtab\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_tabtab.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_tabtab.rollup.js'] =\n            local.assetsDict['/assets.npmtest_tabtab.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_tabtab.__dirname +\n                    '/lib.npmtest_tabtab.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tabtab/node_modules/tabtab/index.js":"var tabtab = module.exports = require('./src');\n","/home/travis/build/npmtest/node-npmtest-tabtab/node_modules/tabtab/src/index.js":"'use strict';\n\nvar Complete = require('./complete');\n\nmodule.exports = tabtab;\ntabtab.Commands = require('./commands');\ntabtab.Complete = Complete;\n\n// Public: Tabtab entry point.\n//\n// It provides the main API to the completion and plumbing system, in the form\n// of an EventEmitter with the following events.\n//\n// options - The options hash as parsed by minimist (default: {})\n//\n// Examples\n//\n//    // The binary name being completed.\n//    complete.on('name', function(data, done) {});\n//\n//    // The very last word being completed, preceding the cursor tab position\n//    complete.on('list', function(data, done) {});\n//\n// Returns an instance of Complete.\nfunction tabtab(options) {\n  return new Complete(options);\n}","/home/travis/build/npmtest/node-npmtest-tabtab/node_modules/tabtab/src/complete.js":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar fs = require('fs');\nvar path = require('path');\nvar read = fs.readFileSync;\nvar exists = fs.existsSync;\nvar join = path.join;\nvar debug = require('./debug')('tabtab:complete');\nvar assign = require('object-assign');\nvar uniq = require('lodash.uniq');\nvar difference = require('lodash.difference');\n\nvar _require = require('events');\n\nvar EventEmitter = _require.EventEmitter;\n\nvar CacheMixin = require('./cache');\n\n// Public: Complete class. This is the main API to interract with the\n// completion system and extends EventEmitter.\n//\n// Examples\n//\n//   var complete = new Complete({\n//     name: 'binary-name'\n//   });\n//\n//   complete.on('list', function(data, done) {\n//     return done(null, ['completion', 'result', 'here']);\n//   });\n\nvar Complete = function (_EventEmitter) {\n  _inherits(Complete, _EventEmitter);\n\n  _createClass(Complete, [{\n    key: 'defaults',\n\n\n    // Public: Options defaults.\n    //\n    // Returns the binary name being completed. Uses process.title if not the\n    // default \"node\" value, or attempt to determine the package name from\n    // package.json file.\n    get: function get() {\n      return {\n        name: process.title !== 'node' ? process.title : ''\n      };\n    }\n\n    // Public: Complete constructor, accepts options hash with\n    //\n    // options -  Accepts options hash (default: {})\n    //\n    // Examples\n    //\n    //   new Complete({\n    //     // the String package name being completed, defaults to process.title\n    //     // (if not node default) or will attempt to determine parent's\n    //     // package.json location and extract the name from it.\n    //     name: 'foobar'\n    //\n    //     // Enable / Disable cache (defaults: true)\n    //     cache: true,\n    //\n    //    // Cache Time To Live duration in ms (default: 5min)\n    //     ttl: 1000 * 60 * 5\n    //   });\n\n  }]);\n\n  function Complete(options) {\n    _classCallCheck(this, Complete);\n\n    var _this = _possibleConstructorReturn(this, (Complete.__proto__ || Object.getPrototypeOf(Complete)).call(this));\n\n    _this.options = options || _this.defaults;\n    _this.options.name = _this.options.name || _this.resolve('name');\n    _this.options.cache = typeof _this.options.cache !== 'undefined' ? _this.options.cache : true;\n    _this.options.ttl = _this.options.ttl || 1000 * 60 * 5;\n\n    _this._results = [];\n    _this._completions = [];\n    return _this;\n  }\n\n  _createClass(Complete, [{\n    key: 'start',\n    value: function start() {\n      this.handle();\n    }\n\n    // Public: Takes care of all the completion plumbing mechanism.\n    //\n    // It checks the environment to determine if we act in plumbing mode or not,\n    // to parse COMP args and emit the appropriated events to gather completion\n    // results.\n    //\n    // options - options hash to pass to self#parseEnv\n\n  }, {\n    key: 'handle',\n    value: function handle(options) {\n      var _this2 = this;\n\n      options = assign({}, options, this.options);\n      var name = options.name;\n      if (!name) throw new Error('Cannot determine package name');\n\n      var env = this.env = this.parseEnv(options);\n      if (env.args[0] !== 'completion') return;\n\n      var line = env.line.replace(name, '').trim();\n      var first = line.split(' ')[0];\n      if (first) first = first.trim();\n\n      var event = (first || env.prev || name).trim();\n      var cache = this.cache(env.line);\n\n      if (this.options.cache && cache) {\n        return process.nextTick(function () {\n          // this.addCompletions(cache.value);\n          _this2.send(event + ':cache', env);\n          debug('cache', cache.value);\n          _this2.output(cache.value);\n        });\n      }\n\n      if (!env.complete) {\n        return debug('Completion command but without COMP args');\n      }\n\n      process.nextTick(function () {\n        _this2.completePackage(env);\n\n        var prev = env.prev.trim();\n        name = name.trim();\n\n        // Keeps emitting event only if previous one is not being listened to.\n        // Emits in series: first, prev and name.\n        _this2.send(event, env, _this2.recv.bind(_this2));\n\n        if (prev !== event) _this2.send(prev, env, _this2.recv.bind(_this2));\n        if (name !== event && name !== prev) _this2.send(name, env, _this2.recv.bind(_this2));\n\n        if (_this2.options.cache) {\n          _this2.cache(env.line, _this2._results);\n          _this2.writeToStore(_this2.cacheStore);\n        }\n      });\n    }\n  }, {\n    key: 'output',\n    value: function output(results) {\n      var _this3 = this;\n\n      var shell = (process.env.SHELL || '').split('/').slice(-1)[0];\n\n      if (shell === 'bash') {\n        results = results.filter(function (res) {\n          return res.indexOf(_this3.env.last) === 0;\n        });\n      }\n\n      // create a duplicate-free version of results\n      results = uniq(results);\n\n      // only include results different from past completion results\n      results = difference(results, this._completions);\n      this._completions = this._completions.concat(results);\n\n      debug('results:', results, this.env);\n      console.log(results.join('\\n'));\n    }\n  }, {\n    key: 'send',\n    value: function send(evt, env, done) {\n      var res = this.emit(evt, env, done);\n      debug('Emit evt: %s (listener: %s)', evt, res);\n      return res;\n    }\n  }, {\n    key: 'completePackage',\n    value: function completePackage(env, stop) {\n      var config = this.resolve('tabtab');\n      if (!config) return;\n\n      var pkgname = config[this.options.name];\n\n      var last = (env.last || env.prev).trim();\n      var prop = last || this.options.name;\n      if (!prop) return;\n\n      if (stop) {\n        var first = env.line.split(' ')[0];\n        var results = config[first];\n        if (!results) return;\n        return this.recv(null, results, env);\n      }\n\n      // Keeps looking up for completion only if previous one have not returned\n      // any results.\n      var command = config[prop];\n      var completions = this.recv(null, command, env);\n\n      if (!completions) {\n        if (last && !stop) {\n          var reg = new RegExp('\\\\s*' + last + '\\\\s*$');\n          var line = env.line.replace(reg, '');\n          this.completePackage(this.parseEnv({\n            env: {\n              COMP_LINE: line,\n              COMP_WORD: env.words,\n              COMP_POINT: env.point\n            }\n          }), true);\n        }\n      }\n\n      return true;\n    }\n\n    // Public: Completions handlers\n    //\n    // will call back this function with an Array of completion items.\n    //\n    // err -          Error object\n    // completions -  The Array of String completion results to write to stdout\n    // env -          Env object as parsed by parseEnv\n\n  }, {\n    key: 'recv',\n    value: function recv(err, completions, env) {\n      if (!completions) return;\n\n      env = env || this.env;\n\n      debug('Received %s', completions);\n      if (err) return this.emit('error', err);\n\n      this.addCompletions(completions);\n      this.output(this._results);\n\n      return completions;\n    }\n  }, {\n    key: 'addCompletions',\n    value: function addCompletions(completions) {\n      completions = Array.isArray(completions) ? completions : [completions];\n      var shell = (process.env.SHELL || '').split('/').slice(-1)[0];\n\n      completions = completions.map(this.completionItem).map(function (item) {\n        return shell === 'zsh' ? item.name.replace(/:/g, '\\\\:') + ':' + item.description : shell === 'fish' ? item.name + '\\t' + item.description : item.name;\n      });\n\n      this._results = this._results.concat(completions);\n    }\n  }, {\n    key: 'completionItem',\n    value: function completionItem(str) {\n      debug('completion item', str, typeof str === 'undefined' ? 'undefined' : _typeof(str));\n\n      if (typeof str !== 'string') return str;\n      var shell = (process.env.SHELL || '').split('/').slice(-1)[0];\n\n      var parts = str.split(/(\\\\)?:/);\n      var name = parts[0];\n      var desc = parts.slice(-1)[0];\n\n      if (desc === name) {\n        desc = '';\n      }\n\n      if (shell === 'zsh' && /\\\\/.test(str)) {\n        name = name + '\\\\';\n      }\n\n      return {\n        name: name,\n        description: desc\n      };\n    }\n\n    // Public: Main utility to extract information from command line arguments and\n    // Environment variables, namely COMP args in \"plumbing\" mode.\n    //\n    // options -  The options hash as parsed by minimist, plus an env property\n    //            representing user environment (default: { env: process.env })\n    //    :_      - The arguments Array parsed by minimist (positional arguments)\n    //    :env    - The environment Object that holds COMP args (default: process.env)\n    //\n    // Examples\n    //\n    //   var env = complete.parseEnv();\n    //   // env:\n    //   // args        the positional arguments used\n    //   // complete    A Boolean indicating whether we act in \"plumbing mode\" or not\n    //   // words       The Number of words in the completed line\n    //   // point       A Number indicating cursor position\n    //   // line        The String input line\n    //   // partial     The String part of line preceding cursor position\n    //   // last        The last String word of the line\n    //   // lastPartial The last word String of partial\n    //   // prev        The String word preceding last\n    //\n    // Returns the data env object.\n\n  }, {\n    key: 'parseEnv',\n    value: function parseEnv(options) {\n      options = options || {};\n      options = assign({}, options, this.options);\n      var args = options._ || process.argv.slice(2);\n      var env = options.env || process.env;\n\n      var cword = Number(env.COMP_CWORD);\n      var point = Number(env.COMP_POINT);\n      var line = env.COMP_LINE || '';\n\n      if (isNaN(cword)) cword = 0;\n      if (isNaN(point)) point = 0;\n\n      var partial = line.slice(0, point);\n\n      var parts = line.split(' ');\n      var prev = parts.slice(0, -1).slice(-1)[0];\n\n      var last = parts.slice(-1).join('');\n      var lastPartial = partial.split(' ').slice(-1).join('');\n\n      var complete = args[0] === 'completion';\n\n      if (!env.COMP_CWORD || typeof env.COMP_POINT === 'undefined' || typeof env.COMP_LINE === 'undefined') {\n        complete = false;\n      }\n\n      return {\n        args: args,\n        complete: complete,\n        words: cword,\n        point: point,\n        line: line,\n        partial: partial,\n        last: last,\n        lastPartial: lastPartial,\n        prev: prev || ''\n      };\n    }\n\n    // Public: Script templating helper\n    //\n    // Outputs npm's completion script with pkgname and completer placeholder\n    // replaced.\n    //\n    // name     - The String package/binary name\n    // complete - The String completer name, usualy the same as name above. Can\n    //            differ to delegate the completion behavior to another command.\n    //\n    // Returns the script content with placeholders replaced\n\n  }, {\n    key: 'script',\n    value: function script(name, completer, shell) {\n      return read(join(__dirname, '../scripts/' + (shell || 'completion') + '.sh'), 'utf8').replace(/\\{pkgname\\}/g, name).replace(/{completer}/g, completer);\n    }\n\n    // Public: Recursively walk up the `module.parent` chain to find original file.\n\n  }, {\n    key: 'findParent',\n    value: function findParent(module, last) {\n      if (!module.parent) return module;\n      return this.findParent(module.parent);\n    }\n\n    // Public: Recursively walk up the directories, untill it finds the `file`\n    // provided, or reach the user $HOME dir.\n\n  }, {\n    key: 'findUp',\n    value: function findUp(file, dir) {\n      dir = path.resolve(dir || './');\n\n      // stop at user $HOME dir\n      if (dir === process.env.HOME) return;\n      if (exists(join(dir, file))) return join(dir, file);\n      return this.findUp(file, path.dirname(dir));\n    }\n\n    // Public: package name resolver.\n    //\n    // When options.name is not defined, this gets called to attempt to determine\n    // completer name.\n    //\n    // It'll attempt to follow the module chain and find the package.json file to\n    // determine the command name being completed.\n\n  }, {\n    key: 'resolve',\n    value: function resolve(prop) {\n      // `module` is special node builtin\n      var parent = this.findParent(module);\n      if (!parent) return;\n\n      var dirname = path.dirname(parent.filename);\n\n      // was invoked by cli tabtab, fallback to local package.json\n      if (parent.filename === path.join(__dirname, '../bin/tabtab')) {\n        dirname = path.resolve();\n      }\n\n      var jsonfile = this.findUp('package.json', dirname);\n      if (!jsonfile) return;\n\n      return require(jsonfile)[prop];\n    }\n  }]);\n\n  return Complete;\n}(EventEmitter);\n\nassign(Complete.prototype, CacheMixin);\n\nmodule.exports = Complete;","/home/travis/build/npmtest/node-npmtest-tabtab/node_modules/tabtab/src/debug.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar util = require('util');\nvar dbg = require('debug');\n\n// process.env.TABTAB_DEBUG = process.env.TABTAB_DEBUG || '/tmp/tabtab.log';\n\nvar out = process.env.TABTAB_DEBUG ? fs.createWriteStream(process.env.TABTAB_DEBUG, { flags: 'a' }) : null;\n\nmodule.exports = debug;\n\n// Internal: Facade to debug module, which provides the exact same interface.\n//\n// The added benefit is with the TABTAB_DEBUG environment variable, which when\n// defined, will write debug output to the specified filename.\n//\n// Usefull when debugging tab completion, as logs on stdout / stderr are either\n// shallowed or used as tab completion results.\n//\n// namespace - The String namespace to use when TABTAB_DEBUG is not defined,\n//             delegates to debug module.\n//\n// Examples\n//\n//    // Use with following command to redirect output to file\n//    // TABTAB_DEBUG=\"debug.log\" tabtab ...\n//    debug('Foo');\nfunction debug(namespace) {\n  var log = dbg(namespace);\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args = args.map(function (arg) {\n      if (typeof arg === 'string') return arg;\n      return JSON.stringify(arg);\n    });\n\n    out && out.write(util.format.apply(util, args) + '\\n');\n    out || log.apply(null, args);\n  };\n}","/home/travis/build/npmtest/node-npmtest-tabtab/node_modules/tabtab/src/cache.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar read = fs.readFileSync;\nvar exists = fs.existsSync;\nvar debug = require('./debug')('tabtab:cache');\nvar cachefile = path.join(__dirname, '../.completions/cache.json');\n\n// Cache mixin\nmodule.exports = {\n  initCache: function initCache() {\n    this._cache = exists(cachefile) ? require(cachefile) : { timestamp: Date.now(), cache: {} };\n    this.cacheStore = this._cache.cache;\n  },\n  cache: function cache(key, value) {\n    if (!this.cacheStore) this.initCache();\n    if (!value) return this.fromStore(key);\n    this.cacheStore[key] = { timestamp: Date.now(), value: value };\n    // this.writeToStore(this.cacheStore);\n  },\n  fromStore: function fromStore(key) {\n    var cache = this.cacheStore[key];\n    if (!cache) return;\n\n    var now = Date.now();\n    var elapsed = now - cache.timestamp;\n    if (elapsed > this.options.ttl) {\n      debug('Cache TTL, invalid cache');\n      delete this.cacheStore[key];\n      this.writeToStore(this.cacheStore);\n    }\n\n    return cache;\n  },\n  writeToStore: function writeToStore(cache) {\n    debug('Writing to %s', cachefile);\n    fs.writeFileSync(cachefile, JSON.stringify({\n      timestamp: Date.now(),\n      cache: cache\n    }, null, 2));\n  }\n};","/home/travis/build/npmtest/node-npmtest-tabtab/node_modules/tabtab/src/commands/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _installer = require('../installer');\n\nvar _installer2 = _interopRequireDefault(_installer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar fs = require('fs');\nvar path = require('path');\nvar join = path.join;\nvar debug = require('../debug')('tabtab:commands');\nvar Complete = require('../complete');\n\nvar _require = require('fs');\n\nvar read = _require.readFileSync;\nvar exists = _require.existsSync;\n\n// Public: Commands class that defines the various command available with tabtab(1)\n//\n// Examples\n//\n//   // TODO: document all methods\n//\n//   var commands = new Commands({});\n//   commands.install();\n\nvar Commands = function () {\n  _createClass(Commands, [{\n    key: 'allowed',\n    get: function get() {\n      return ['install', 'uninstall', 'list', 'search', 'add', 'rm', 'completion'];\n    }\n\n    // Public: Creates a new command instance. this.complete is an instance of\n    // Complete.\n\n  }]);\n\n  function Commands(options) {\n    _classCallCheck(this, Commands);\n\n    this.options = options || {};\n    this.complete = new Complete(this.options);\n    this.installer = new _installer2.default(this.options, this.complete);\n    this.shell = (process.env.SHELL || '').split('/').slice(-1)[0];\n  }\n\n  // Commands\n\n  // Public: Fow now, just output to the console\n\n\n  _createClass(Commands, [{\n    key: 'install',\n    value: function install(options) {\n      options = options || {};\n      var script = this.complete.script(this.name, this.name || 'tabtab');\n\n      var shell = process.env.SHELL;\n      if (shell) shell = shell.split(process.platform !== 'win32' ? '/' : '\\\\').slice(-1)[0];\n      if (!this.installer[shell]) {\n        return debug('User shell %s not supported, skipping completion install', shell);\n      }\n\n      this.installer.handle(this.options.name || this.complete.resolve('name'), options).catch(function (e) {\n        console.error('oh oh', e.stack);\n        process.exit(1);\n      });\n    }\n\n    // Public: Delegates to this.handle\n\n  }, {\n    key: 'completion',\n    value: function completion(options) {\n      options = options || this.options;\n      return this.complete.handle(options);\n    }\n\n    // Public: to be implemented.\n\n  }, {\n    key: 'uninstall',\n    value: function uninstall(options) {\n      debug('Trigger uninstall command', options);\n      if (!options.auto) throw new Error('Uninstall only available with --auto flag');\n\n      var dest = this.shell === 'zsh' ? '~/.zshrc' : this.shell === 'bash' ? '~/.bashrc' : '~/.config/fish/config.fish';\n\n      // win32 ?\n      dest = dest.replace('~', process.env.HOME);\n\n      debug('Destination:', dest);\n      this.installer.uninstallCompletion(dest).catch(function (e) {\n        throw e;\n      }).then(function () {\n        console.log('uninstall end');\n      });\n    }\n\n    // Public: to be implemented.\n\n  }, {\n    key: 'search',\n    value: function search() {}\n\n    // Public: to be implemented.\n\n  }, {\n    key: 'list',\n    value: function list() {}\n\n    // Public: to be implemented.\n\n  }, {\n    key: 'add',\n    value: function add() {}\n\n    // Public: to be implemented.\n\n  }, {\n    key: 'rm',\n    value: function rm() {}\n\n    // Public: --help output\n    //\n    // Returns the String output\n\n  }, {\n    key: 'help',\n    value: function help() {\n      return '\\n    $ tabtab <command> [options]\\n\\n    Options:\\n      -h, --help              Show this help output\\n      -v, --version           Show package version\\n      --name                  Binary name tabtab should complete\\n      --auto                  Use default SHELL configuration file\\n                              (~/.bashrc, ~/.zshrc or ~/.config/fish/config.fish)\\n\\n    Commands:\\n\\n      install                 Install and enable completion file on user system\\n      uninstall               Undo the install command\\n    ';\n      // list                    List the completion files managed by tabtab\n      // search                  Search npm registry for tabtab completion files / dictionaries\n      // add                     Install additional completion files / dictionaries\n      // rm/remove               Uninstall completion file / dictionnary\n    }\n  }]);\n\n  return Commands;\n}();\n\nexports.default = Commands;\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-tabtab/node_modules/tabtab/src/installer.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _inquirer = require('inquirer');\n\nvar _inquirer2 = _interopRequireDefault(_inquirer);\n\nvar _child_process = require('child_process');\n\nvar _mkdirp = require('mkdirp');\n\nvar _mkdirp2 = _interopRequireDefault(_mkdirp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar debug = require('./debug')('tabtab:installer');\n\nvar errmsg = '\\nError: You don\\'t have permission to write to :destination.\\nTry running with sudo instead:\\n\\n  sudo ' + process.argv.join(' ') + '\\n';\n\n// Public: Manage installation / setup of completion scripts.\n//\n// pkg-config --variable=completionsdir bash-completion\n// pkg-config --variable=compatdir bash-completion\n\nvar Installer = function () {\n  _createClass(Installer, [{\n    key: 'home',\n    get: function get() {\n      return process.env[process.platform == 'win32' ? 'USERPROFILE' : 'HOME'];\n    }\n  }]);\n\n  function Installer(options, complete) {\n    _classCallCheck(this, Installer);\n\n    this.options = options || {};\n    this.complete = complete;\n\n    this._shell = (process.env.SHELL || '').split('/').slice(-1)[0];\n    this.dest = this._shell === 'zsh' ? 'zshrc' : this._shell === 'bash' ? 'bashrc' : 'fish';\n\n    this.dest = this.dest.replace('~', process.env.HOME);\n  }\n\n  // Called on install command.\n  //\n  // Performs the installation process.\n\n\n  _createClass(Installer, [{\n    key: 'handle',\n    value: function handle(name, options) {\n      var _this = this;\n\n      this.options.name = name;\n\n      if (options.stdout) return new Promise(function (r, errback) {\n        return _this.writeTo({\n          destination: 'stdout'\n        });\n      });\n\n      if (options.auto) {\n        this.template = this._shell;\n        return this.writeTo({ destination: this.dest });\n      }\n\n      return this.prompt().then(this.writeTo.bind(this));\n    }\n  }, {\n    key: 'writeTo',\n    value: function writeTo(data) {\n      var destination = data.destination;\n      debug('Installing completion script to %s directory', destination);\n\n      var script = this.complete.script(this.options.name, this.options.completer || this.options.name, this.template);\n\n      if (destination === 'stdout') return process.stdout.write('\\n\\n' + script + '\\n');\n\n      if (destination === 'bashrc') destination = _path2.default.join(this.home, '.bashrc');else if (destination === 'zshrc') destination = _path2.default.join(this.home, '.zshrc');else if (destination === 'fish') destination = _path2.default.join(this.home, '.config/fish/config.fish');else if (destination === 'fishdir') destination = _path2.default.join(this.home, '.config/fish/completions', this.options.name + '.fish');else destination = _path2.default.join(destination, this.options.name);\n\n      return new Promise(this.createStream.bind(this, destination)).then(this.installCompletion.bind(this, destination));\n    }\n  }, {\n    key: 'createStream',\n    value: function createStream(destination, r, errback) {\n      // debug('Check %s destination', destination);\n      var flags = 'a';\n      _fs2.default.stat(destination, function (err, stat) {\n        if (err && err.code === 'ENOENT') flags = 'w';else if (err) return errback(err);\n\n        (0, _mkdirp2.default)(_path2.default.dirname(destination), function (err) {\n          if (err) return errback(err);\n\n          var out = _fs2.default.createWriteStream(destination, { flags: flags });\n          out.on('error', function (err) {\n            if (err.code === 'EACCES') {\n              console.error(errmsg.replace(':destination', destination));\n            }\n            return errback(err);\n          });\n\n          out.on('open', function () {\n            debug('Installing completion script to %s directory', destination);\n            debug('Writing to %s file in %s mode', destination, flags === 'a' ? 'append' : 'write');\n            r(out);\n          });\n        });\n      });\n    }\n  }, {\n    key: 'installCompletion',\n    value: function installCompletion(destination, out) {\n      var _this2 = this;\n\n      var name = this.options.name;\n      var script = this.complete.script(name, this.options.completer || name, this.template);\n      var filename = _path2.default.join(__dirname, '../.completions', name + '.' + this.template);\n      if (process.platform === 'win32') {\n        filename = filename.replace(/\\\\/g, '/');\n      } // win32: replace backslashes with forward slashes\n      debug('Writing actual completion script to %s', filename);\n\n      // First write internal completion script in a local .comletions directory\n      // in this module. This gets sourced in user scripts after, to avoid\n      // cluttering bash/zshrc files with too much boilerplate.\n      return new Promise(function (r, errback) {\n        _fs2.default.writeFile(filename, script, function (err) {\n          if (err) return errback(err);\n\n          var regex = new RegExp('tabtab source for ' + name);\n          _fs2.default.readFile(destination, 'utf8', function (err, content) {\n            if (err) return errback(err);\n            if (regex.test(content)) {\n              return debug('Already installed %s in %s', name, destination);\n            }\n\n            console.error('\\n[tabtab] Adding source line to load %s\\nin %s\\n', filename, destination);\n\n            debug('. %s > %s', filename, destination);\n            out.write('\\n# tabtab source for ' + name + ' package');\n            out.write('\\n# uninstall by removing these lines or running ');\n            out.write('`tabtab uninstall ' + name + '`');\n\n            if (_this2.template === 'fish') {\n              out.write('\\n[ -f ' + filename + ' ]; and . ' + filename);\n            } else if (_this2.template === 'zsh') {\n              out.write('\\n[[ -f ' + filename + ' ]] && . ' + filename);\n            } else {\n              out.write('\\n[ -f ' + filename + ' ] && . ' + filename);\n            }\n          });\n        });\n      });\n    }\n  }, {\n    key: 'uninstallCompletion',\n    value: function uninstallCompletion(destination) {\n      var _this3 = this;\n\n      return new Promise(function (r, errback) {\n        _fs2.default.readFile(destination, 'utf8', function (err, body) {\n          if (err) return errback(err);\n          r(body);\n        });\n      }).then(function (body) {\n        var lines = body.split(/\\r?\\n/);\n\n        debug('Uninstall', _this3.options);\n        var name = _this3.options.name;\n        var reg = new RegExp('(tabtab source for ' + name + ' package|`tabtab uninstall ' + name + '`|tabtab/.completions/' + name + ')');\n        lines = lines.filter(function (line) {\n          return !reg.test(line);\n        });\n\n        return lines.join('\\n');\n      }).then(function (content) {\n        return new Promise(function (r, errback) {\n          _fs2.default.writeFile(destination, content, function (err) {\n            if (err) return errback(err);\n            debug('%s sucesfully updated to remove tabtab', destination);\n          });\n        });\n      });\n    }\n\n    // Prompts user for installation location.\n\n  }, {\n    key: 'prompt',\n    value: function prompt() {\n      var choices = [{\n        name: 'Nowhere. Just output to STDOUT',\n        value: 'stdout',\n        short: 'stdout'\n      }];\n\n      var prompts = [{\n        message: 'Where do you want to setup the completion script',\n        name: 'destination',\n        type: 'list',\n        choices: choices\n      }];\n\n      return this.shell().then(function (entries) {\n        prompts[0].choices = choices.concat(entries);\n        return _inquirer2.default.prompt(prompts);\n      });\n    }\n\n    // Shell adapters.\n    //\n    // Supported:\n    //\n    // - bash   - Asks pkg-config for completion directories\n    // - zsh    - Lookup $fpath environment variable\n    // - fish   - Lookup for $fish_complete_path\n\n  }, {\n    key: 'shell',\n    value: function shell() {\n      var _this4 = this;\n\n      return new Promise(function (r, errback) {\n        var shell = process.env.SHELL;\n        if (shell) shell = shell.split(process.platform !== 'win32' ? '/' : '\\\\').slice(-1)[0];\n\n        return _this4[shell]().then(r).catch(errback);\n      });\n    }\n  }, {\n    key: 'fish',\n    value: function fish() {\n      var _this5 = this;\n\n      debug('Fish shell detected');\n      this.template = 'fish';\n      return new Promise(function (r, errback) {\n        var dir = _path2.default.join(_this5.home, '.config/fish/completions');\n        return r([{\n          name: 'Fish config file (~/.config/fish/config.fish)',\n          value: 'fish',\n          short: 'fish'\n        }, {\n          name: 'Fish completion directory (' + dir + ')',\n          value: 'fishdir',\n          short: 'fish'\n        }]);\n      });\n    }\n  }, {\n    key: 'bash',\n    value: function bash() {\n      var _this6 = this;\n\n      debug('Bash shell detected');\n      this.template = 'bash';\n      var entries = [{\n        name: 'Bash config file (~/.bashrc)',\n        value: 'bashrc',\n        short: 'bash'\n      }];\n\n      return this.completionsdir().then(function (dir) {\n        debug(dir);\n        if (dir) {\n          entries.push({\n            name: 'Bash completionsdir ( ' + dir + ' )',\n            value: dir\n          });\n        }\n        return _this6.compatdir();\n      }).then(function (dir) {\n        if (dir) {\n          entries.push({\n            name: 'Bash compatdir ( ' + dir + ' )',\n            value: dir\n          });\n        }\n\n        return entries;\n      });\n    }\n  }, {\n    key: 'zsh',\n    value: function zsh() {\n      debug('Zsh shell detected');\n      this.template = 'zsh';\n      return new Promise(function (r, errback) {\n        var dir = '/usr/local/share/zsh/site-functions';\n        return r([{\n          name: 'Zsh config file (~/.zshrc)',\n          value: 'zshrc',\n          short: 'zsh'\n        }, {\n          name: 'Zsh completion directory (' + dir + ')',\n          value: dir\n        }]);\n      });\n    }\n\n    // Bash\n\n    // Public: pkg-config wrapper\n\n  }, {\n    key: 'pkgconfig',\n    value: function pkgconfig(variable) {\n      return new Promise(function (r, errback) {\n        var cmd = 'pkg-config --variable=' + variable + ' bash-completion';\n        debug('cmd', cmd);\n        (0, _child_process.exec)(cmd, function (err, stdout, stderr) {\n          if (err) {\n            // silently fail if pkg-config bash-completion returns an error,\n            // meaning bash-completion is either not installed or misconfigured\n            // with PKG_CONFIG_PATH\n            return r();\n          }\n          stdout = stdout.trim();\n          debug('Got %s for %s', stdout, variable);\n          r(stdout);\n        });\n      });\n    }\n\n    // Returns the pkg-config variable for \"completionsdir\" and bash-completion\n\n  }, {\n    key: 'completionsdir',\n    value: function completionsdir() {\n      debug('Asking pkg-config for completionsdir');\n      return this.pkgconfig('completionsdir');\n    }\n\n    // Returns the pkg-config variable for \"compatdir\" and bash-completion\n\n  }, {\n    key: 'compatdir',\n    value: function compatdir() {\n      debug('Asking pkg-config for compatdir');\n      return this.pkgconfig('compatdir');\n    }\n  }]);\n\n  return Installer;\n}();\n\nexports.default = Installer;\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-tabtab/node_modules/tabtab/lib/cache.js":"const fs        = require('fs');\nconst path      = require('path');\nconst read      = fs.readFileSync;\nconst exists    = fs.existsSync;\nconst debug     = require('./debug')('tabtab:cache');\nconst cachefile = path.join(__dirname, '../.completions/cache.json');\n\n// Cache mixin\nmodule.exports = {\n  initCache() {\n    this._cache = exists(cachefile) ? require(cachefile) : { timestamp: Date.now(), cache: {} };\n    this.cacheStore = this._cache.cache;\n  },\n\n  cache(key, value) {\n    if (!this.cacheStore) this.initCache();\n    if (!value) return this.fromStore(key);\n    this.cacheStore[key] = { timestamp: Date.now(), value};\n    // this.writeToStore(this.cacheStore);\n  },\n\n  fromStore(key) {\n    var cache = this.cacheStore[key];\n    if (!cache) return;\n\n    var now = Date.now();\n    var elapsed = now - cache.timestamp;\n    if (elapsed > this.options.ttl) {\n      debug('Cache TTL, invalid cache');\n      delete this.cacheStore[key];\n      this.writeToStore(this.cacheStore);\n    }\n\n    return cache;\n  },\n\n  writeToStore(cache) {\n    debug('Writing to %s', cachefile);\n    fs.writeFileSync(cachefile, JSON.stringify({\n      timestamp: Date.now(),\n      cache: cache\n    }, null, 2));\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-tabtab/node_modules/tabtab/lib/debug.js":"const fs    = require('fs');\nconst path  = require('path');\nconst util  = require('util');\nconst dbg   = require('debug');\n\n// process.env.TABTAB_DEBUG = process.env.TABTAB_DEBUG || '/tmp/tabtab.log';\n\nlet out = process.env.TABTAB_DEBUG ?\n  fs.createWriteStream(process.env.TABTAB_DEBUG, { flags: 'a' }) :\n  null;\n\nmodule.exports = debug;\n\n// Internal: Facade to debug module, which provides the exact same interface.\n//\n// The added benefit is with the TABTAB_DEBUG environment variable, which when\n// defined, will write debug output to the specified filename.\n//\n// Usefull when debugging tab completion, as logs on stdout / stderr are either\n// shallowed or used as tab completion results.\n//\n// namespace - The String namespace to use when TABTAB_DEBUG is not defined,\n//             delegates to debug module.\n//\n// Examples\n//\n//    // Use with following command to redirect output to file\n//    // TABTAB_DEBUG=\"debug.log\" tabtab ...\n//    debug('Foo');\nfunction debug(namespace) {\n  var log = dbg(namespace);\n  return (...args) => {\n\n    args = args.map((arg) => {\n      if (typeof arg === 'string') return arg;\n      return JSON.stringify(arg);\n    });\n\n    out && out.write(util.format.apply(util, args) + '\\n');\n    out || log.apply(null, args);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-tabtab/node_modules/tabtab/lib/complete.js":"const fs         = require('fs');\nconst path       = require('path');\nconst read       = fs.readFileSync;\nconst exists     = fs.existsSync;\nconst join       = path.join;\nconst debug      = require('./debug')('tabtab:complete');\nconst assign     = require('object-assign');\nconst uniq       = require('lodash.uniq');\nconst difference = require('lodash.difference');\nconst { EventEmitter } = require('events');\nconst CacheMixin  = require('./cache');\n\n// Public: Complete class. This is the main API to interract with the\n// completion system and extends EventEmitter.\n//\n// Examples\n//\n//   var complete = new Complete({\n//     name: 'binary-name'\n//   });\n//\n//   complete.on('list', function(data, done) {\n//     return done(null, ['completion', 'result', 'here']);\n//   });\nclass Complete extends EventEmitter {\n\n  // Public: Options defaults.\n  //\n  // Returns the binary name being completed. Uses process.title if not the\n  // default \"node\" value, or attempt to determine the package name from\n  // package.json file.\n  get defaults() {\n    return {\n      name: process.title !== 'node' ? process.title : ''\n    };\n  }\n\n  // Public: Complete constructor, accepts options hash with\n  //\n  // options -  Accepts options hash (default: {})\n  //\n  // Examples\n  //\n  //   new Complete({\n  //     // the String package name being completed, defaults to process.title\n  //     // (if not node default) or will attempt to determine parent's\n  //     // package.json location and extract the name from it.\n  //     name: 'foobar'\n  //\n  //     // Enable / Disable cache (defaults: true)\n  //     cache: true,\n  //\n  //    // Cache Time To Live duration in ms (default: 5min)\n  //     ttl: 1000 * 60 * 5\n  //   });\n  constructor(options) {\n    super();\n    this.options = options || this.defaults;\n    this.options.name = this.options.name || this.resolve('name');\n    this.options.cache = typeof this.options.cache !== 'undefined' ? this.options.cache : true;\n    this.options.ttl = this.options.ttl || (1000 * 60 * 5);\n\n    this._results = [];\n    this._completions = [];\n  }\n\n  start() {\n    this.handle();\n  }\n\n  // Public: Takes care of all the completion plumbing mechanism.\n  //\n  // It checks the environment to determine if we act in plumbing mode or not,\n  // to parse COMP args and emit the appropriated events to gather completion\n  // results.\n  //\n  // options - options hash to pass to self#parseEnv\n  handle(options) {\n    options = assign({}, options, this.options);\n    var name = options.name;\n    if (!name) throw new Error('Cannot determine package name');\n\n    var env = this.env = this.parseEnv(options);\n    if (env.args[0] !== 'completion') return;\n\n    var line = env.line.replace(name, '').trim();\n    var first = line.split(' ')[0];\n    if (first) first = first.trim();\n\n    var event = (first || env.prev || name).trim();\n    var cache = this.cache(env.line);\n\n    if (this.options.cache && cache) {\n      return process.nextTick(() => {\n        // this.addCompletions(cache.value);\n        this.send(event + ':cache', env);\n        debug('cache', cache.value);\n        this.output(cache.value);\n      });\n    }\n\n    if (!env.complete) {\n      return debug('Completion command but without COMP args');\n    }\n\n    process.nextTick(() => {\n      this.completePackage(env);\n\n      var prev = env.prev.trim();\n      name = name.trim();\n\n      // Keeps emitting event only if previous one is not being listened to.\n      // Emits in series: first, prev and name.\n      this.send(event, env, this.recv.bind(this));\n\n      if (prev !== event) this.send(prev, env, this.recv.bind(this));\n      if (name !== event && name !== prev) this.send(name, env, this.recv.bind(this));\n\n      if (this.options.cache) {\n        this.cache(env.line, this._results);\n        this.writeToStore(this.cacheStore);\n      }\n    });\n  }\n\n  output(results) {\n    var shell = (process.env.SHELL || '').split('/').slice(-1)[0];\n\n    if (shell === 'bash') {\n      results = results.filter((res) => {\n        return res.indexOf(this.env.last) === 0;\n      });\n    }\n\n    // create a duplicate-free version of results\n    results = uniq(results);\n\n    // only include results different from past completion results\n    results = difference(results, this._completions);\n    this._completions = this._completions.concat(results);\n\n    debug('results:', results, this.env);\n    console.log(results.join('\\n'));\n  }\n\n  send(evt, env, done) {\n    var res = this.emit(evt, env, done);\n    debug('Emit evt: %s (listener: %s)', evt, res);\n    return res;\n  }\n\n  completePackage(env, stop) {\n    var config = this.resolve('tabtab');\n    if (!config) return;\n\n    var pkgname = config[this.options.name];\n\n    var last = (env.last || env.prev).trim();\n    var prop = last || this.options.name;\n    if (!prop) return;\n\n    if (stop) {\n      let first = env.line.split(' ')[0];\n      let results = config[first];\n      if (!results) return;\n      return this.recv(null, results, env);\n    }\n\n    // Keeps looking up for completion only if previous one have not returned\n    // any results.\n    var command = config[prop];\n    var completions = this.recv(null, command, env);\n\n    if (!completions) {\n      if (last && !stop) {\n        let reg = new RegExp('\\\\s*' + last + '\\\\s*$');\n        let line = env.line.replace(reg, '');\n        this.completePackage(this.parseEnv({\n          env: {\n            COMP_LINE: line,\n            COMP_WORD: env.words,\n            COMP_POINT: env.point\n          }\n        }), true);\n      }\n    }\n\n    return true\n  }\n\n  // Public: Completions handlers\n  //\n  // will call back this function with an Array of completion items.\n  //\n  // err -          Error object\n  // completions -  The Array of String completion results to write to stdout\n  // env -          Env object as parsed by parseEnv\n  recv(err, completions, env) {\n    if (!completions) return;\n\n    env = env || this.env;\n\n    debug('Received %s', completions);\n    if (err) return this.emit('error', err);\n\n    this.addCompletions(completions);\n    this.output(this._results);\n\n    return completions;\n  }\n\n  addCompletions(completions) {\n    completions = Array.isArray(completions) ? completions : [completions];\n    var shell = (process.env.SHELL || '').split('/').slice(-1)[0];\n\n    completions = completions.map(this.completionItem).map((item) => {\n      return shell === 'zsh' ? `${item.name.replace(/:/g, '\\\\:')}:${item.description}` :\n        shell === 'fish' ? `${item.name}\\t${item.description}` :\n        item.name;\n    });\n\n    this._results = this._results.concat(completions);\n  }\n\n  completionItem(str) {\n    debug('completion item', str, typeof str);\n\n    if (typeof str !== 'string') return str;\n    var shell = (process.env.SHELL || '').split('/').slice(-1)[0];\n\n    var parts = str.split(/(\\\\)?:/);\n    var name = parts[0];\n    var desc = parts.slice(-1)[0];\n\n    if (desc === name) {\n      desc = '';\n    }\n\n    if (shell === 'zsh' && /\\\\/.test(str)) {\n      name = name + '\\\\';\n    }\n\n    return {\n      name: name,\n      description: desc\n    };\n  }\n\n  // Public: Main utility to extract information from command line arguments and\n  // Environment variables, namely COMP args in \"plumbing\" mode.\n  //\n  // options -  The options hash as parsed by minimist, plus an env property\n  //            representing user environment (default: { env: process.env })\n  //    :_      - The arguments Array parsed by minimist (positional arguments)\n  //    :env    - The environment Object that holds COMP args (default: process.env)\n  //\n  // Examples\n  //\n  //   var env = complete.parseEnv();\n  //   // env:\n  //   // args        the positional arguments used\n  //   // complete    A Boolean indicating whether we act in \"plumbing mode\" or not\n  //   // words       The Number of words in the completed line\n  //   // point       A Number indicating cursor position\n  //   // line        The String input line\n  //   // partial     The String part of line preceding cursor position\n  //   // last        The last String word of the line\n  //   // lastPartial The last word String of partial\n  //   // prev        The String word preceding last\n  //\n  // Returns the data env object.\n  parseEnv(options) {\n    options = options || {}\n    options = assign({}, options, this.options);\n    var args = options._ || process.argv.slice(2);\n    var env = options.env || process.env;\n\n    var cword = Number(env.COMP_CWORD);\n    var point = Number(env.COMP_POINT);\n    var line = env.COMP_LINE || '';\n\n    if (isNaN(cword)) cword = 0;\n    if (isNaN(point)) point = 0;\n\n    var partial = line.slice(0, point);\n\n    var parts = line.split(' ');\n    var prev = parts.slice(0, -1).slice(-1)[0];\n\n    var last = parts.slice(-1).join('');\n    var lastPartial = partial.split(' ').slice(-1).join('');\n\n    var complete = args[0] === 'completion';\n\n    if (!env.COMP_CWORD || typeof env.COMP_POINT === 'undefined' || typeof env.COMP_LINE === 'undefined') {\n      complete = false;\n    }\n\n    return {\n      args: args,\n      complete: complete,\n      words: cword,\n      point: point,\n      line: line,\n      partial: partial,\n      last: last,\n      lastPartial: lastPartial,\n      prev: prev || ''\n    };\n  }\n\n  // Public: Script templating helper\n  //\n  // Outputs npm's completion script with pkgname and completer placeholder\n  // replaced.\n  //\n  // name     - The String package/binary name\n  // complete - The String completer name, usualy the same as name above. Can\n  //            differ to delegate the completion behavior to another command.\n  //\n  // Returns the script content with placeholders replaced\n  script(name, completer, shell) {\n    return read(join(__dirname, `../scripts/${shell || 'completion'}.sh`), 'utf8')\n      .replace(/\\{pkgname\\}/g, name)\n      .replace(/{completer}/g, completer);\n  }\n\n  // Public: Recursively walk up the `module.parent` chain to find original file.\n  findParent(module, last) {\n    if (!module.parent) return module;\n    return this.findParent(module.parent);\n  }\n\n  // Public: Recursively walk up the directories, untill it finds the `file`\n  // provided, or reach the user $HOME dir.\n  findUp(file, dir) {\n    dir = path.resolve(dir || './');\n\n    // stop at user $HOME dir\n    if (dir === process.env.HOME) return;\n    if (exists(join(dir, file))) return join(dir, file);\n    return this.findUp(file, path.dirname(dir));\n  }\n\n  // Public: package name resolver.\n  //\n  // When options.name is not defined, this gets called to attempt to determine\n  // completer name.\n  //\n  // It'll attempt to follow the module chain and find the package.json file to\n  // determine the command name being completed.\n  resolve(prop) {\n    // `module` is special node builtin\n    var parent = this.findParent(module);\n    if (!parent) return;\n\n    var dirname = path.dirname(parent.filename);\n\n    // was invoked by cli tabtab, fallback to local package.json\n    if (parent.filename === path.join(__dirname, '../bin/tabtab')) {\n      dirname = path.resolve();\n    }\n\n    var jsonfile = this.findUp('package.json', dirname);\n    if (!jsonfile) return;\n\n    return require(jsonfile)[prop];\n  }\n}\n\nassign(Complete.prototype, CacheMixin);\n\nmodule.exports = Complete;\n","/home/travis/build/npmtest/node-npmtest-tabtab/node_modules/tabtab/lib/installer.js":"const debug = require('./debug')('tabtab:installer')\n\nimport fs from                'fs';\nimport path from              'path';\nimport inquirer from          'inquirer';\nimport { spawn, exec } from   'child_process';\nimport mkdirp from            'mkdirp';\n\nlet errmsg = `\nError: You don't have permission to write to :destination.\nTry running with sudo instead:\n\n  sudo ${process.argv.join(' ')}\n`;\n\n// Public: Manage installation / setup of completion scripts.\n//\n// pkg-config --variable=completionsdir bash-completion\n// pkg-config --variable=compatdir bash-completion\nexport default class Installer {\n  get home() {\n    return process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'];\n  }\n\n  constructor(options, complete) {\n    this.options = options || {};\n    this.complete = complete;\n\n    this._shell = (process.env.SHELL || '').split('/').slice(-1)[0];\n    this.dest = this._shell === 'zsh' ? 'zshrc' :\n      this._shell === 'bash' ? 'bashrc' :\n      'fish';\n\n    this.dest = this.dest.replace('~', process.env.HOME);\n  }\n\n  // Called on install command.\n  //\n  // Performs the installation process.\n  handle(name, options) {\n    this.options.name = name;\n\n    if (options.stdout) return new Promise((r, errback) => {\n      return this.writeTo({\n        destination: 'stdout'\n      });\n    });\n\n    if (options.auto) {\n      this.template = this._shell;\n      return this.writeTo({ destination: this.dest });\n    }\n\n    return this.prompt().then(this.writeTo.bind(this));\n  }\n\n  writeTo(data) {\n    var destination = data.destination;\n    debug('Installing completion script to %s directory', destination);\n\n    var script = this.complete.script(this.options.name, this.options.completer || this.options.name, this.template);\n\n    if (destination === 'stdout') return process.stdout.write('\\n\\n' + script + '\\n');\n\n    if (destination === 'bashrc') destination = path.join(this.home, '.bashrc');\n    else if (destination === 'zshrc') destination = path.join(this.home, '.zshrc');\n    else if (destination === 'fish') destination = path.join(this.home, '.config/fish/config.fish');\n    else if (destination === 'fishdir') destination = path.join(this.home, '.config/fish/completions', this.options.name + '.fish');\n    else destination = path.join(destination, this.options.name);\n\n    return new Promise(this.createStream.bind(this, destination))\n      .then(this.installCompletion.bind(this, destination));\n  }\n\n  createStream(destination, r, errback) {\n    // debug('Check %s destination', destination);\n    var flags = 'a';\n    fs.stat(destination, (err, stat) => {\n      if (err && err.code === 'ENOENT') flags = 'w';\n      else if (err) return errback(err);\n\n      mkdirp(path.dirname(destination), (err) => {\n        if (err) return errback(err);\n\n        var out = fs.createWriteStream(destination, { flags });\n        out.on('error', (err) => {\n          if (err.code === 'EACCES') {\n            console.error(errmsg.replace(':destination', destination));\n          }\n          return errback(err);\n        });\n\n        out.on('open', () => {\n          debug('Installing completion script to %s directory', destination);\n          debug('Writing to %s file in %s mode', destination, flags === 'a' ? 'append' : 'write');\n          r(out);\n        });\n      });\n    });\n  }\n\n  installCompletion(destination, out) {\n    var name = this.options.name;\n    var script = this.complete.script(name, this.options.completer || name, this.template);\n    var filename = path.join(__dirname, '../.completions', name + '.' + this.template);\n    if(process.platform === 'win32') { filename = filename.replace(/\\\\/g, '/'); } // win32: replace backslashes with forward slashes\n    debug('Writing actual completion script to %s', filename);\n\n    // First write internal completion script in a local .comletions directory\n    // in this module. This gets sourced in user scripts after, to avoid\n    // cluttering bash/zshrc files with too much boilerplate.\n    return new Promise((r, errback) => {\n      fs.writeFile(filename, script, (err) => {\n        if (err) return errback(err);\n\n        var regex = new RegExp(`tabtab source for ${name}`);\n        fs.readFile(destination, 'utf8', (err, content) => {\n          if (err) return errback(err);\n          if (regex.test(content)) {\n            return debug('Already installed %s in %s', name, destination);\n          }\n\n          console.error('\\n[tabtab] Adding source line to load %s\\nin %s\\n', filename, destination);\n\n          debug('. %s > %s', filename, destination);\n          out.write('\\n# tabtab source for ' + name + ' package');\n          out.write('\\n# uninstall by removing these lines or running ');\n          out.write('`tabtab uninstall ' + name + '`');\n\n          if (this.template === 'fish') {\n            out.write('\\n[ -f ' + filename + ' ]; and . ' + filename);\n          } else if (this.template === 'zsh') {\n            out.write('\\n[[ -f ' + filename + ' ]] && . ' + filename);\n          } else {\n            out.write('\\n[ -f ' + filename + ' ] && . ' + filename);\n          }\n        });\n      });\n    });\n  }\n\n  uninstallCompletion(destination) {\n    return new Promise((r, errback) => {\n      fs.readFile(destination, 'utf8', (err, body) => {\n        if (err) return errback(err);\n        r(body);\n      });\n    })\n\n    .then((body) => {\n      var lines = body.split(/\\r?\\n/);\n\n      debug('Uninstall', this.options);\n      var name = this.options.name;\n      var reg = new RegExp('(tabtab source for ' + name + ' package|`tabtab uninstall ' + name + '`|tabtab/.completions/' + name + ')');\n      lines = lines.filter((line) => {\n        return !reg.test(line);\n      });\n\n      return lines.join('\\n');\n    })\n\n    .then((content) => {\n      return new Promise((r, errback) => {\n        fs.writeFile(destination, content, (err) => {\n          if (err) return errback(err);\n          debug('%s sucesfully updated to remove tabtab', destination);\n        });\n      });\n    });\n  }\n\n  // Prompts user for installation location.\n  prompt() {\n    var choices = [{\n      name:   'Nowhere. Just output to STDOUT',\n      value:  'stdout',\n      short:  'stdout'\n    }];\n\n    var prompts = [{\n      message: 'Where do you want to setup the completion script',\n      name: 'destination',\n      type: 'list',\n      choices: choices\n    }];\n\n    return this.shell()\n      .then((entries) => {\n        prompts[0].choices = choices.concat(entries);\n        return inquirer.prompt(prompts);\n      });\n  }\n\n  // Shell adapters.\n  //\n  // Supported:\n  //\n  // - bash   - Asks pkg-config for completion directories\n  // - zsh    - Lookup $fpath environment variable\n  // - fish   - Lookup for $fish_complete_path\n  shell() {\n    return new Promise((r, errback) => {\n      var shell = process.env.SHELL;\n      if (shell) shell = shell.split((process.platform !== 'win32') ? '/' : '\\\\').slice(-1)[0];\n\n      return this[shell]().then(r)\n        .catch(errback);\n    });\n  }\n\n  fish() {\n    debug('Fish shell detected');\n    this.template = 'fish';\n    return new Promise((r, errback) => {\n      var dir = path.join(this.home, '.config/fish/completions');\n      return r([{\n        name: 'Fish config file (~/.config/fish/config.fish)',\n        value: 'fish',\n        short: 'fish'\n      }, {\n        name: 'Fish completion directory (' + dir + ')',\n        value: 'fishdir',\n        short: 'fish'\n      }]);\n    });\n  }\n\n  bash() {\n    debug('Bash shell detected');\n    this.template = 'bash';\n    var entries = [{\n      name:   'Bash config file (~/.bashrc)',\n      value:  'bashrc',\n      short:  'bash'\n    }];\n\n    return this.completionsdir()\n      .then((dir) => {\n        debug(dir);\n        if (dir) {\n          entries.push({\n            name: 'Bash completionsdir ( ' + dir + ' )',\n            value: dir\n          });\n        }\n        return this.compatdir();\n      })\n      .then((dir) => {\n        if (dir) {\n          entries.push({\n            name: 'Bash compatdir ( ' + dir + ' )',\n            value: dir\n          });\n        }\n\n        return entries;\n      });\n  }\n\n  zsh() {\n    debug('Zsh shell detected');\n    this.template = 'zsh';\n    return new Promise((r, errback) => {\n      var dir = '/usr/local/share/zsh/site-functions';\n      return r([{\n        name:   'Zsh config file (~/.zshrc)',\n        value:  'zshrc',\n        short:  'zsh'\n      }, {\n        name: 'Zsh completion directory (' + dir + ')',\n        value: dir\n      }]);\n    });\n  }\n\n  // Bash\n\n  // Public: pkg-config wrapper\n  pkgconfig(variable) {\n    return new Promise((r, errback) => {\n      var cmd = `pkg-config --variable=${variable} bash-completion`;\n      debug('cmd', cmd);\n      exec(cmd, function(err, stdout, stderr) {\n        if (err) {\n          // silently fail if pkg-config bash-completion returns an error,\n          // meaning bash-completion is either not installed or misconfigured\n          // with PKG_CONFIG_PATH\n          return r();\n        }\n        stdout = stdout.trim();\n        debug('Got %s for %s', stdout, variable);\n        r(stdout);\n      });\n    });\n  }\n\n  // Returns the pkg-config variable for \"completionsdir\" and bash-completion\n  completionsdir() {\n    debug('Asking pkg-config for completionsdir');\n    return this.pkgconfig('completionsdir');\n  }\n\n  // Returns the pkg-config variable for \"compatdir\" and bash-completion\n  compatdir() {\n    debug('Asking pkg-config for compatdir');\n    return this.pkgconfig('compatdir');\n  }\n}\n"}